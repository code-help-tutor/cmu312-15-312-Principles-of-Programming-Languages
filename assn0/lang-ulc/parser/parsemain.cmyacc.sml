(* File generated by CM-Yacc version 2.1 *)

functor ParseMainFun
  (structure Streamable: STREAMABLE
   structure Arg:
   sig
     type string
     type stmts
     type bool
     type stmt
     type term

     val termvar: string -> term
     val termapp: term * term -> term
     val termnorm: term -> term
     val termabs: string * term -> term
     val termid: term -> term
     val stmtassert: bool * term * bool * term -> stmt
     val stmtprint: bool * term -> stmt
     val stmtundef: string -> stmt
     val stmtdef: bool * string * term -> stmt
     val btrue: unit -> bool
     val bfalse: unit -> bool
     val stmtscons: stmt * stmts -> stmts
     val stmtsnil: unit -> stmts

     datatype terminal =
       IDENT of string
     | LPAREN
     | RPAREN
     | DOT
     | LAMBDA
     | NORM
     | DEF
     | DEF_FORCE
     | UNDEF
     | PRINT
     | PRINT_FORCE
     | ASSERT
     | ASSERT_FORCE
     | EQ
     | NEQ

     val error: terminal Streamable.t -> exn
   end) :>
sig
  val parse: Arg.terminal Streamable.t -> Arg.stmts * Arg.terminal Streamable.t
end =

(*

AUTOMATON LISTING
=================

State 0:

start -> . Stmts  / 0
0 : Stmts -> .  / 0
1 : Stmts -> . Stmt Stmts  / 0
2 : Def -> . DEF  / 1
3 : Def -> . DEF_FORCE  / 1
4 : Print -> . PRINT  / 2
5 : Print -> . PRINT_FORCE  / 2
6 : Assert -> . ASSERT  / 2
7 : Assert -> . ASSERT_FORCE  / 2
10 : Stmt -> . Def IDENT EQ Term  / 3
11 : Stmt -> . UNDEF IDENT  / 3
12 : Stmt -> . Print Term  / 3
13 : Stmt -> . Assert Term Compare Term  / 3

$ => reduce 0
DEF => shift 6
DEF_FORCE => shift 5
UNDEF => shift 4
PRINT => shift 9
PRINT_FORCE => shift 10
ASSERT => shift 8
ASSERT_FORCE => shift 11
Stmts => goto 7
Stmt => goto 12
Def => goto 3
Print => goto 2
Assert => goto 1

-----

State 1:

13 : Stmt -> Assert . Term Compare Term  / 3
14 : Term -> . AppTerm  / 4
15 : Term -> . LAMBDA IDENT DOT Term  / 4
16 : Term -> . NORM Term  / 4
17 : AppTerm -> . Atom  / 5
18 : AppTerm -> . AppTerm Atom  / 5
19 : Atom -> . LPAREN Term RPAREN  / 5
20 : Atom -> . IDENT  / 5

IDENT => shift 13
LPAREN => shift 14
LAMBDA => shift 15
NORM => shift 17
Term => goto 18
AppTerm => goto 16
Atom => goto 19

-----

State 2:

12 : Stmt -> Print . Term  / 3
14 : Term -> . AppTerm  / 3
15 : Term -> . LAMBDA IDENT DOT Term  / 3
16 : Term -> . NORM Term  / 3
17 : AppTerm -> . Atom  / 6
18 : AppTerm -> . AppTerm Atom  / 6
19 : Atom -> . LPAREN Term RPAREN  / 6
20 : Atom -> . IDENT  / 6

IDENT => shift 13
LPAREN => shift 14
LAMBDA => shift 15
NORM => shift 17
Term => goto 20
AppTerm => goto 16
Atom => goto 19

-----

State 3:

10 : Stmt -> Def . IDENT EQ Term  / 3

IDENT => shift 21

-----

State 4:

11 : Stmt -> UNDEF . IDENT  / 3

IDENT => shift 22

-----

State 5:

3 : Def -> DEF_FORCE .  / 1

IDENT => reduce 3

-----

State 6:

2 : Def -> DEF .  / 1

IDENT => reduce 2

-----

State 7:

start -> Stmts .  / 0

$ => accept

-----

State 8:

6 : Assert -> ASSERT .  / 2

IDENT => reduce 6
LPAREN => reduce 6
LAMBDA => reduce 6
NORM => reduce 6

-----

State 9:

4 : Print -> PRINT .  / 2

IDENT => reduce 4
LPAREN => reduce 4
LAMBDA => reduce 4
NORM => reduce 4

-----

State 10:

5 : Print -> PRINT_FORCE .  / 2

IDENT => reduce 5
LPAREN => reduce 5
LAMBDA => reduce 5
NORM => reduce 5

-----

State 11:

7 : Assert -> ASSERT_FORCE .  / 2

IDENT => reduce 7
LPAREN => reduce 7
LAMBDA => reduce 7
NORM => reduce 7

-----

State 12:

0 : Stmts -> .  / 0
1 : Stmts -> . Stmt Stmts  / 0
1 : Stmts -> Stmt . Stmts  / 0
2 : Def -> . DEF  / 1
3 : Def -> . DEF_FORCE  / 1
4 : Print -> . PRINT  / 2
5 : Print -> . PRINT_FORCE  / 2
6 : Assert -> . ASSERT  / 2
7 : Assert -> . ASSERT_FORCE  / 2
10 : Stmt -> . Def IDENT EQ Term  / 3
11 : Stmt -> . UNDEF IDENT  / 3
12 : Stmt -> . Print Term  / 3
13 : Stmt -> . Assert Term Compare Term  / 3

$ => reduce 0
DEF => shift 6
DEF_FORCE => shift 5
UNDEF => shift 4
PRINT => shift 9
PRINT_FORCE => shift 10
ASSERT => shift 8
ASSERT_FORCE => shift 11
Stmts => goto 23
Stmt => goto 12
Def => goto 3
Print => goto 2
Assert => goto 1

-----

State 13:

20 : Atom -> IDENT .  / 7

$ => reduce 20
IDENT => reduce 20
LPAREN => reduce 20
RPAREN => reduce 20
DEF => reduce 20
DEF_FORCE => reduce 20
UNDEF => reduce 20
PRINT => reduce 20
PRINT_FORCE => reduce 20
ASSERT => reduce 20
ASSERT_FORCE => reduce 20
EQ => reduce 20
NEQ => reduce 20

-----

State 14:

14 : Term -> . AppTerm  / 8
15 : Term -> . LAMBDA IDENT DOT Term  / 8
16 : Term -> . NORM Term  / 8
17 : AppTerm -> . Atom  / 9
18 : AppTerm -> . AppTerm Atom  / 9
19 : Atom -> . LPAREN Term RPAREN  / 9
19 : Atom -> LPAREN . Term RPAREN  / 7
20 : Atom -> . IDENT  / 9

IDENT => shift 13
LPAREN => shift 14
LAMBDA => shift 15
NORM => shift 17
Term => goto 24
AppTerm => goto 16
Atom => goto 19

-----

State 15:

15 : Term -> LAMBDA . IDENT DOT Term  / 10

IDENT => shift 25

-----

State 16:

14 : Term -> AppTerm .  / 10
18 : AppTerm -> AppTerm . Atom  / 7
19 : Atom -> . LPAREN Term RPAREN  / 7
20 : Atom -> . IDENT  / 7

$ => reduce 14
IDENT => shift 13
LPAREN => shift 14
RPAREN => reduce 14
DEF => reduce 14
DEF_FORCE => reduce 14
UNDEF => reduce 14
PRINT => reduce 14
PRINT_FORCE => reduce 14
ASSERT => reduce 14
ASSERT_FORCE => reduce 14
EQ => reduce 14
NEQ => reduce 14
Atom => goto 26

-----

State 17:

14 : Term -> . AppTerm  / 10
15 : Term -> . LAMBDA IDENT DOT Term  / 10
16 : Term -> . NORM Term  / 10
16 : Term -> NORM . Term  / 10
17 : AppTerm -> . Atom  / 7
18 : AppTerm -> . AppTerm Atom  / 7
19 : Atom -> . LPAREN Term RPAREN  / 7
20 : Atom -> . IDENT  / 7

IDENT => shift 13
LPAREN => shift 14
LAMBDA => shift 15
NORM => shift 17
Term => goto 27
AppTerm => goto 16
Atom => goto 19

-----

State 18:

8 : Compare -> . EQ  / 2
9 : Compare -> . NEQ  / 2
13 : Stmt -> Assert Term . Compare Term  / 3

EQ => shift 30
NEQ => shift 29
Compare => goto 28

-----

State 19:

17 : AppTerm -> Atom .  / 7

$ => reduce 17
IDENT => reduce 17
LPAREN => reduce 17
RPAREN => reduce 17
DEF => reduce 17
DEF_FORCE => reduce 17
UNDEF => reduce 17
PRINT => reduce 17
PRINT_FORCE => reduce 17
ASSERT => reduce 17
ASSERT_FORCE => reduce 17
EQ => reduce 17
NEQ => reduce 17

-----

State 20:

12 : Stmt -> Print Term .  / 3

$ => reduce 12
DEF => reduce 12
DEF_FORCE => reduce 12
UNDEF => reduce 12
PRINT => reduce 12
PRINT_FORCE => reduce 12
ASSERT => reduce 12
ASSERT_FORCE => reduce 12

-----

State 21:

10 : Stmt -> Def IDENT . EQ Term  / 3

EQ => shift 31

-----

State 22:

11 : Stmt -> UNDEF IDENT .  / 3

$ => reduce 11
DEF => reduce 11
DEF_FORCE => reduce 11
UNDEF => reduce 11
PRINT => reduce 11
PRINT_FORCE => reduce 11
ASSERT => reduce 11
ASSERT_FORCE => reduce 11

-----

State 23:

1 : Stmts -> Stmt Stmts .  / 0

$ => reduce 1

-----

State 24:

19 : Atom -> LPAREN Term . RPAREN  / 7

RPAREN => shift 32

-----

State 25:

15 : Term -> LAMBDA IDENT . DOT Term  / 10

DOT => shift 33

-----

State 26:

18 : AppTerm -> AppTerm Atom .  / 7

$ => reduce 18
IDENT => reduce 18
LPAREN => reduce 18
RPAREN => reduce 18
DEF => reduce 18
DEF_FORCE => reduce 18
UNDEF => reduce 18
PRINT => reduce 18
PRINT_FORCE => reduce 18
ASSERT => reduce 18
ASSERT_FORCE => reduce 18
EQ => reduce 18
NEQ => reduce 18

-----

State 27:

16 : Term -> NORM Term .  / 10

$ => reduce 16
RPAREN => reduce 16
DEF => reduce 16
DEF_FORCE => reduce 16
UNDEF => reduce 16
PRINT => reduce 16
PRINT_FORCE => reduce 16
ASSERT => reduce 16
ASSERT_FORCE => reduce 16
EQ => reduce 16
NEQ => reduce 16

-----

State 28:

13 : Stmt -> Assert Term Compare . Term  / 3
14 : Term -> . AppTerm  / 3
15 : Term -> . LAMBDA IDENT DOT Term  / 3
16 : Term -> . NORM Term  / 3
17 : AppTerm -> . Atom  / 6
18 : AppTerm -> . AppTerm Atom  / 6
19 : Atom -> . LPAREN Term RPAREN  / 6
20 : Atom -> . IDENT  / 6

IDENT => shift 13
LPAREN => shift 14
LAMBDA => shift 15
NORM => shift 17
Term => goto 34
AppTerm => goto 16
Atom => goto 19

-----

State 29:

9 : Compare -> NEQ .  / 2

IDENT => reduce 9
LPAREN => reduce 9
LAMBDA => reduce 9
NORM => reduce 9

-----

State 30:

8 : Compare -> EQ .  / 2

IDENT => reduce 8
LPAREN => reduce 8
LAMBDA => reduce 8
NORM => reduce 8

-----

State 31:

10 : Stmt -> Def IDENT EQ . Term  / 3
14 : Term -> . AppTerm  / 3
15 : Term -> . LAMBDA IDENT DOT Term  / 3
16 : Term -> . NORM Term  / 3
17 : AppTerm -> . Atom  / 6
18 : AppTerm -> . AppTerm Atom  / 6
19 : Atom -> . LPAREN Term RPAREN  / 6
20 : Atom -> . IDENT  / 6

IDENT => shift 13
LPAREN => shift 14
LAMBDA => shift 15
NORM => shift 17
Term => goto 35
AppTerm => goto 16
Atom => goto 19

-----

State 32:

19 : Atom -> LPAREN Term RPAREN .  / 7

$ => reduce 19
IDENT => reduce 19
LPAREN => reduce 19
RPAREN => reduce 19
DEF => reduce 19
DEF_FORCE => reduce 19
UNDEF => reduce 19
PRINT => reduce 19
PRINT_FORCE => reduce 19
ASSERT => reduce 19
ASSERT_FORCE => reduce 19
EQ => reduce 19
NEQ => reduce 19

-----

State 33:

14 : Term -> . AppTerm  / 10
15 : Term -> . LAMBDA IDENT DOT Term  / 10
15 : Term -> LAMBDA IDENT DOT . Term  / 10
16 : Term -> . NORM Term  / 10
17 : AppTerm -> . Atom  / 7
18 : AppTerm -> . AppTerm Atom  / 7
19 : Atom -> . LPAREN Term RPAREN  / 7
20 : Atom -> . IDENT  / 7

IDENT => shift 13
LPAREN => shift 14
LAMBDA => shift 15
NORM => shift 17
Term => goto 36
AppTerm => goto 16
Atom => goto 19

-----

State 34:

13 : Stmt -> Assert Term Compare Term .  / 3

$ => reduce 13
DEF => reduce 13
DEF_FORCE => reduce 13
UNDEF => reduce 13
PRINT => reduce 13
PRINT_FORCE => reduce 13
ASSERT => reduce 13
ASSERT_FORCE => reduce 13

-----

State 35:

10 : Stmt -> Def IDENT EQ Term .  / 3

$ => reduce 10
DEF => reduce 10
DEF_FORCE => reduce 10
UNDEF => reduce 10
PRINT => reduce 10
PRINT_FORCE => reduce 10
ASSERT => reduce 10
ASSERT_FORCE => reduce 10

-----

State 36:

15 : Term -> LAMBDA IDENT DOT Term .  / 10

$ => reduce 15
RPAREN => reduce 15
DEF => reduce 15
DEF_FORCE => reduce 15
UNDEF => reduce 15
PRINT => reduce 15
PRINT_FORCE => reduce 15
ASSERT => reduce 15
ASSERT_FORCE => reduce 15
EQ => reduce 15
NEQ => reduce 15

-----

lookahead 0 = $
lookahead 1 = IDENT
lookahead 2 = IDENT LPAREN LAMBDA NORM
lookahead 3 = $ DEF DEF_FORCE UNDEF PRINT PRINT_FORCE ASSERT ASSERT_FORCE
lookahead 4 = EQ NEQ
lookahead 5 = IDENT LPAREN EQ NEQ
lookahead 6 = $ IDENT LPAREN DEF DEF_FORCE UNDEF PRINT PRINT_FORCE ASSERT ASSERT_FORCE
lookahead 7 = $ IDENT LPAREN RPAREN DEF DEF_FORCE UNDEF PRINT PRINT_FORCE ASSERT ASSERT_FORCE EQ NEQ
lookahead 8 = RPAREN
lookahead 9 = IDENT LPAREN RPAREN
lookahead 10 = $ RPAREN DEF DEF_FORCE UNDEF PRINT PRINT_FORCE ASSERT ASSERT_FORCE EQ NEQ

*)

struct
  local
    structure Value =
    struct
      datatype nonterminal =
        nonterminal
      | string of Arg.string
      | stmts of Arg.stmts
      | bool of Arg.bool
      | stmt of Arg.stmt
      | term of Arg.term
    end
    structure ParseEngine =
      ParseEngineFun
        (structure Streamable = Streamable
         type terminal = Arg.terminal
         type value = Value.nonterminal
         val dummy = Value.nonterminal
         fun read terminal =
           (case terminal of
              Arg.IDENT x => (1, Value.string x)
            | Arg.LPAREN => (2, Value.nonterminal)
            | Arg.RPAREN => (3, Value.nonterminal)
            | Arg.DOT => (4, Value.nonterminal)
            | Arg.LAMBDA => (5, Value.nonterminal)
            | Arg.NORM => (6, Value.nonterminal)
            | Arg.DEF => (7, Value.nonterminal)
            | Arg.DEF_FORCE => (8, Value.nonterminal)
            | Arg.UNDEF => (9, Value.nonterminal)
            | Arg.PRINT => (10, Value.nonterminal)
            | Arg.PRINT_FORCE => (11, Value.nonterminal)
            | Arg.ASSERT => (12, Value.nonterminal)
            | Arg.ASSERT_FORCE => (13, Value.nonterminal)
            | Arg.EQ => (14, Value.nonterminal)
            | Arg.NEQ => (15, Value.nonterminal)))
  in
    val parse = ParseEngine.parse
      ( ParseEngine.next5x1
          "~\128\128\128\128\128\128\135\134\133\138\139\137\140\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\142\143\128\128\144\146\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\142\143\128\128\144\146\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\150\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\151\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128{\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128|\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\127\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128xx\128\128xx\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128zz\128\128zz\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128yy\128\128yy\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128ww\128\128ww\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128~\128\128\128\128\128\128\135\134\133\138\139\137\140\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128jjjj\128\128\128jjjjjjjjj\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\142\143\128\128\144\146\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\154\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128p\142\143p\128\128\128ppppppppp\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\142\143\128\128\144\146\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\159\158\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128mmmm\128\128\128mmmmmmmmm\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128r\128\128\128\128\128\128rrrrrrr\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\160\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128s\128\128\128\128\128\128sssssss\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128}\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\161\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\162\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128llll\128\128\128lllllllll\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128n\128\128n\128\128\128nnnnnnnnn\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\142\143\128\128\144\146\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128uu\128\128uu\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128vv\128\128vv\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\142\143\128\128\144\146\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128kkkk\128\128\128kkkkkkkkk\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\142\143\128\128\144\146\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128q\128\128\128\128\128\128qqqqqqq\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128t\128\128\128\128\128\128ttttttt\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128o\128\128o\128\128\128ooooooooo\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128"
      , ParseEngine.next5x1
          "\135\140\131\130\129\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\146\144\147\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\148\144\147\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\151\140\131\130\129\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\152\144\147\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\154\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\155\144\147\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\156\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\162\144\147\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\163\144\147\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\164\144\147\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128"
      , Vector.fromList
          [ (0, 0, (fn rest => Value.stmts (Arg.stmtsnil {}) :: rest))
          , ( 0
            , 2
            , (fn Value.stmts (arg0) :: Value.stmt (arg1) :: rest =>
                 Value.stmts (Arg.stmtscons {2 = arg0, 1 = arg1}) :: rest
                | _ => raise (Fail "bad parser"))
            )
          , ( 2
            , 1
            , (fn _ :: rest => Value.bool (Arg.bfalse {}) :: rest
                | _ => raise (Fail "bad parser"))
            )
          , ( 2
            , 1
            , (fn _ :: rest => Value.bool (Arg.btrue {}) :: rest
                | _ => raise (Fail "bad parser"))
            )
          , ( 3
            , 1
            , (fn _ :: rest => Value.bool (Arg.bfalse {}) :: rest
                | _ => raise (Fail "bad parser"))
            )
          , ( 3
            , 1
            , (fn _ :: rest => Value.bool (Arg.btrue {}) :: rest
                | _ => raise (Fail "bad parser"))
            )
          , ( 4
            , 1
            , (fn _ :: rest => Value.bool (Arg.bfalse {}) :: rest
                | _ => raise (Fail "bad parser"))
            )
          , ( 4
            , 1
            , (fn _ :: rest => Value.bool (Arg.btrue {}) :: rest
                | _ => raise (Fail "bad parser"))
            )
          , ( 5
            , 1
            , (fn _ :: rest => Value.bool (Arg.btrue {}) :: rest
                | _ => raise (Fail "bad parser"))
            )
          , ( 5
            , 1
            , (fn _ :: rest => Value.bool (Arg.bfalse {}) :: rest
                | _ => raise (Fail "bad parser"))
            )
          , ( 1
            , 4
            , (fn Value.term (arg0) ::
                   _ :: Value.string (arg1) :: Value.bool (arg2) :: rest =>
                 Value.stmt (Arg.stmtdef {3 = arg0, 2 = arg1, 1 = arg2}) :: rest
                | _ => raise (Fail "bad parser"))
            )
          , ( 1
            , 2
            , (fn Value.string (arg0) :: _ :: rest =>
                 Value.stmt (Arg.stmtundef arg0) :: rest
                | _ => raise (Fail "bad parser"))
            )
          , ( 1
            , 2
            , (fn Value.term (arg0) :: Value.bool (arg1) :: rest =>
                 Value.stmt (Arg.stmtprint {2 = arg0, 1 = arg1}) :: rest
                | _ => raise (Fail "bad parser"))
            )
          , ( 1
            , 4
            , (fn Value.term (arg0) ::
                   Value.bool (arg1) ::
                     Value.term (arg2) :: Value.bool (arg3) :: rest =>
                 Value.stmt (Arg.stmtassert
                   {4 = arg0, 3 = arg1, 2 = arg2, 1 = arg3}) :: rest
                | _ => raise (Fail "bad parser"))
            )
          , ( 6
            , 1
            , (fn Value.term (arg0) :: rest =>
                 Value.term (Arg.termid arg0) :: rest
                | _ => raise (Fail "bad parser"))
            )
          , ( 6
            , 4
            , (fn Value.term (arg0) :: _ :: Value.string (arg1) :: _ :: rest =>
                 Value.term (Arg.termabs {2 = arg0, 1 = arg1}) :: rest
                | _ => raise (Fail "bad parser"))
            )
          , ( 6
            , 2
            , (fn Value.term (arg0) :: _ :: rest =>
                 Value.term (Arg.termnorm arg0) :: rest
                | _ => raise (Fail "bad parser"))
            )
          , ( 7
            , 1
            , (fn Value.term (arg0) :: rest =>
                 Value.term (Arg.termid arg0) :: rest
                | _ => raise (Fail "bad parser"))
            )
          , ( 7
            , 2
            , (fn Value.term (arg0) :: Value.term (arg1) :: rest =>
                 Value.term (Arg.termapp {2 = arg0, 1 = arg1}) :: rest
                | _ => raise (Fail "bad parser"))
            )
          , ( 8
            , 3
            , (fn _ :: Value.term (arg0) :: _ :: rest =>
                 Value.term (Arg.termid arg0) :: rest
                | _ => raise (Fail "bad parser"))
            )
          , ( 8
            , 1
            , (fn Value.string (arg0) :: rest =>
                 Value.term (Arg.termvar arg0) :: rest
                | _ => raise (Fail "bad parser"))
            )
          ]
      , (fn Value.stmts x => x | _ => raise (Fail "bad parser"))
      , Arg.error
      )
  end
end
