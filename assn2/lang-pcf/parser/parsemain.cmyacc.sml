(* File generated by CM-Yacc version 2.1 *)

functor ParseMain
  (structure Streamable: STREAMABLE
   structure Arg:
   sig
     type string
     type int
     type typ
     type unittp
     type exp

     val exp_fun: typ * typ * string * string * exp -> exp
     val exp_succ: exp -> exp
     val exp_ap: exp * exp -> exp
     val exp_ifz: exp * exp * string * exp -> exp
     val exp_number: int -> exp
     val exp_zero: unit -> exp
     val exp_var: string -> exp
     val exp_id: exp -> exp
     val unittm: unit -> unittp
     val typ_nat: unit -> typ
     val typ_arrow: typ * typ -> typ
     val typ_id: typ -> typ

     datatype terminal =
       IDENT of string
     | STRING of string
     | LANGLE
     | RANGLE
     | LBRACE
     | RBRACE
     | LBRACKET
     | RBRACKET
     | LPAREN
     | RPAREN
     | ARROW
     | BAR
     | COLON
     | COMMA
     | DARROW
     | DOT
     | EQUAL
     | PLUS
     | STAR
     | SEMICOLON
     | NAT
     | ZERO
     | SUCC
     | NUMBER of int
     | IFZ
     | FUN
     | IS

     val error: terminal Streamable.t -> exn
   end) :>
sig
  val parse: Arg.terminal Streamable.t -> Arg.exp * Arg.terminal Streamable.t
end =

(*

AUTOMATON LISTING
=================

State 0:

start -> . Exp  / 0
5 : ExpAtom -> . LPAREN Exp RPAREN  / 1
6 : ExpAtom -> . IDENT  / 1
7 : ExpAtom -> . ZERO  / 1
8 : ExpAtom -> . NUMBER  / 1
9 : ExpAtom -> . IFZ Exp LBRACE BarOrNot ZERO DARROW Exp BAR SUCC IDENT DARROW Exp RBRACE  / 1
10 : ExpApp -> . ExpAtom  / 1
11 : ExpApp -> . ExpApp ExpAtom  / 1
12 : ExpApp -> . SUCC ExpAtom  / 1
13 : Exp -> . ExpApp  / 0
14 : Exp -> . FUN IDENT LPAREN IDENT COLON Typ RPAREN COLON Typ IS Exp  / 0

IDENT => shift 6
LPAREN => shift 5
ZERO => shift 4
SUCC => shift 3
NUMBER => shift 7
IFZ => shift 2
FUN => shift 1
ExpAtom => goto 9
Exp => goto 10
ExpApp => goto 8

-----

State 1:

14 : Exp -> FUN . IDENT LPAREN IDENT COLON Typ RPAREN COLON Typ IS Exp  / 2

IDENT => shift 11

-----

State 2:

5 : ExpAtom -> . LPAREN Exp RPAREN  / 3
6 : ExpAtom -> . IDENT  / 3
7 : ExpAtom -> . ZERO  / 3
8 : ExpAtom -> . NUMBER  / 3
9 : ExpAtom -> . IFZ Exp LBRACE BarOrNot ZERO DARROW Exp BAR SUCC IDENT DARROW Exp RBRACE  / 3
9 : ExpAtom -> IFZ . Exp LBRACE BarOrNot ZERO DARROW Exp BAR SUCC IDENT DARROW Exp RBRACE  / 4
10 : ExpApp -> . ExpAtom  / 3
11 : ExpApp -> . ExpApp ExpAtom  / 3
12 : ExpApp -> . SUCC ExpAtom  / 3
13 : Exp -> . ExpApp  / 5
14 : Exp -> . FUN IDENT LPAREN IDENT COLON Typ RPAREN COLON Typ IS Exp  / 5

IDENT => shift 6
LPAREN => shift 5
ZERO => shift 4
SUCC => shift 3
NUMBER => shift 7
IFZ => shift 2
FUN => shift 1
ExpAtom => goto 9
Exp => goto 12
ExpApp => goto 8

-----

State 3:

5 : ExpAtom -> . LPAREN Exp RPAREN  / 4
6 : ExpAtom -> . IDENT  / 4
7 : ExpAtom -> . ZERO  / 4
8 : ExpAtom -> . NUMBER  / 4
9 : ExpAtom -> . IFZ Exp LBRACE BarOrNot ZERO DARROW Exp BAR SUCC IDENT DARROW Exp RBRACE  / 4
12 : ExpApp -> SUCC . ExpAtom  / 4

IDENT => shift 6
LPAREN => shift 5
ZERO => shift 4
NUMBER => shift 7
IFZ => shift 2
ExpAtom => goto 13

-----

State 4:

7 : ExpAtom -> ZERO .  / 4

$ => reduce 7
IDENT => reduce 7
LBRACE => reduce 7
RBRACE => reduce 7
LPAREN => reduce 7
RPAREN => reduce 7
BAR => reduce 7
ZERO => reduce 7
NUMBER => reduce 7
IFZ => reduce 7

-----

State 5:

5 : ExpAtom -> . LPAREN Exp RPAREN  / 6
5 : ExpAtom -> LPAREN . Exp RPAREN  / 4
6 : ExpAtom -> . IDENT  / 6
7 : ExpAtom -> . ZERO  / 6
8 : ExpAtom -> . NUMBER  / 6
9 : ExpAtom -> . IFZ Exp LBRACE BarOrNot ZERO DARROW Exp BAR SUCC IDENT DARROW Exp RBRACE  / 6
10 : ExpApp -> . ExpAtom  / 6
11 : ExpApp -> . ExpApp ExpAtom  / 6
12 : ExpApp -> . SUCC ExpAtom  / 6
13 : Exp -> . ExpApp  / 7
14 : Exp -> . FUN IDENT LPAREN IDENT COLON Typ RPAREN COLON Typ IS Exp  / 7

IDENT => shift 6
LPAREN => shift 5
ZERO => shift 4
SUCC => shift 3
NUMBER => shift 7
IFZ => shift 2
FUN => shift 1
ExpAtom => goto 9
Exp => goto 14
ExpApp => goto 8

-----

State 6:

6 : ExpAtom -> IDENT .  / 4

$ => reduce 6
IDENT => reduce 6
LBRACE => reduce 6
RBRACE => reduce 6
LPAREN => reduce 6
RPAREN => reduce 6
BAR => reduce 6
ZERO => reduce 6
NUMBER => reduce 6
IFZ => reduce 6

-----

State 7:

8 : ExpAtom -> NUMBER .  / 4

$ => reduce 8
IDENT => reduce 8
LBRACE => reduce 8
RBRACE => reduce 8
LPAREN => reduce 8
RPAREN => reduce 8
BAR => reduce 8
ZERO => reduce 8
NUMBER => reduce 8
IFZ => reduce 8

-----

State 8:

5 : ExpAtom -> . LPAREN Exp RPAREN  / 4
6 : ExpAtom -> . IDENT  / 4
7 : ExpAtom -> . ZERO  / 4
8 : ExpAtom -> . NUMBER  / 4
9 : ExpAtom -> . IFZ Exp LBRACE BarOrNot ZERO DARROW Exp BAR SUCC IDENT DARROW Exp RBRACE  / 4
11 : ExpApp -> ExpApp . ExpAtom  / 4
13 : Exp -> ExpApp .  / 2

$ => reduce 13
IDENT => shift 6
LBRACE => reduce 13
RBRACE => reduce 13
LPAREN => shift 5
RPAREN => reduce 13
BAR => reduce 13
ZERO => shift 4
NUMBER => shift 7
IFZ => shift 2
ExpAtom => goto 15

-----

State 9:

10 : ExpApp -> ExpAtom .  / 4

$ => reduce 10
IDENT => reduce 10
LBRACE => reduce 10
RBRACE => reduce 10
LPAREN => reduce 10
RPAREN => reduce 10
BAR => reduce 10
ZERO => reduce 10
NUMBER => reduce 10
IFZ => reduce 10

-----

State 10:

start -> Exp .  / 0

$ => accept

-----

State 11:

14 : Exp -> FUN IDENT . LPAREN IDENT COLON Typ RPAREN COLON Typ IS Exp  / 2

LPAREN => shift 16

-----

State 12:

9 : ExpAtom -> IFZ Exp . LBRACE BarOrNot ZERO DARROW Exp BAR SUCC IDENT DARROW Exp RBRACE  / 4

LBRACE => shift 17

-----

State 13:

12 : ExpApp -> SUCC ExpAtom .  / 4

$ => reduce 12
IDENT => reduce 12
LBRACE => reduce 12
RBRACE => reduce 12
LPAREN => reduce 12
RPAREN => reduce 12
BAR => reduce 12
ZERO => reduce 12
NUMBER => reduce 12
IFZ => reduce 12

-----

State 14:

5 : ExpAtom -> LPAREN Exp . RPAREN  / 4

RPAREN => shift 18

-----

State 15:

11 : ExpApp -> ExpApp ExpAtom .  / 4

$ => reduce 11
IDENT => reduce 11
LBRACE => reduce 11
RBRACE => reduce 11
LPAREN => reduce 11
RPAREN => reduce 11
BAR => reduce 11
ZERO => reduce 11
NUMBER => reduce 11
IFZ => reduce 11

-----

State 16:

14 : Exp -> FUN IDENT LPAREN . IDENT COLON Typ RPAREN COLON Typ IS Exp  / 2

IDENT => shift 19

-----

State 17:

3 : BarOrNot -> .  / 8
4 : BarOrNot -> . BAR  / 8
9 : ExpAtom -> IFZ Exp LBRACE . BarOrNot ZERO DARROW Exp BAR SUCC IDENT DARROW Exp RBRACE  / 4

BAR => shift 21
ZERO => reduce 3
BarOrNot => goto 20

-----

State 18:

5 : ExpAtom -> LPAREN Exp RPAREN .  / 4

$ => reduce 5
IDENT => reduce 5
LBRACE => reduce 5
RBRACE => reduce 5
LPAREN => reduce 5
RPAREN => reduce 5
BAR => reduce 5
ZERO => reduce 5
NUMBER => reduce 5
IFZ => reduce 5

-----

State 19:

14 : Exp -> FUN IDENT LPAREN IDENT . COLON Typ RPAREN COLON Typ IS Exp  / 2

COLON => shift 22

-----

State 20:

9 : ExpAtom -> IFZ Exp LBRACE BarOrNot . ZERO DARROW Exp BAR SUCC IDENT DARROW Exp RBRACE  / 4

ZERO => shift 23

-----

State 21:

4 : BarOrNot -> BAR .  / 8

ZERO => reduce 4

-----

State 22:

0 : Typ -> . LPAREN Typ RPAREN  / 9
1 : Typ -> . Typ ARROW Typ  / 9
2 : Typ -> . NAT  / 9
14 : Exp -> FUN IDENT LPAREN IDENT COLON . Typ RPAREN COLON Typ IS Exp  / 2

LPAREN => shift 26
NAT => shift 25
Typ => goto 24

-----

State 23:

9 : ExpAtom -> IFZ Exp LBRACE BarOrNot ZERO . DARROW Exp BAR SUCC IDENT DARROW Exp RBRACE  / 4

DARROW => shift 27

-----

State 24:

1 : Typ -> Typ . ARROW Typ  / 9
14 : Exp -> FUN IDENT LPAREN IDENT COLON Typ . RPAREN COLON Typ IS Exp  / 2

RPAREN => shift 28
ARROW => shift 29

-----

State 25:

2 : Typ -> NAT .  / 10

RPAREN => reduce 2
ARROW => reduce 2
IS => reduce 2

-----

State 26:

0 : Typ -> . LPAREN Typ RPAREN  / 9
0 : Typ -> LPAREN . Typ RPAREN  / 10
1 : Typ -> . Typ ARROW Typ  / 9
2 : Typ -> . NAT  / 9

LPAREN => shift 26
NAT => shift 25
Typ => goto 30

-----

State 27:

5 : ExpAtom -> . LPAREN Exp RPAREN  / 11
6 : ExpAtom -> . IDENT  / 11
7 : ExpAtom -> . ZERO  / 11
8 : ExpAtom -> . NUMBER  / 11
9 : ExpAtom -> . IFZ Exp LBRACE BarOrNot ZERO DARROW Exp BAR SUCC IDENT DARROW Exp RBRACE  / 11
9 : ExpAtom -> IFZ Exp LBRACE BarOrNot ZERO DARROW . Exp BAR SUCC IDENT DARROW Exp RBRACE  / 4
10 : ExpApp -> . ExpAtom  / 11
11 : ExpApp -> . ExpApp ExpAtom  / 11
12 : ExpApp -> . SUCC ExpAtom  / 11
13 : Exp -> . ExpApp  / 12
14 : Exp -> . FUN IDENT LPAREN IDENT COLON Typ RPAREN COLON Typ IS Exp  / 12

IDENT => shift 6
LPAREN => shift 5
ZERO => shift 4
SUCC => shift 3
NUMBER => shift 7
IFZ => shift 2
FUN => shift 1
ExpAtom => goto 9
Exp => goto 31
ExpApp => goto 8

-----

State 28:

14 : Exp -> FUN IDENT LPAREN IDENT COLON Typ RPAREN . COLON Typ IS Exp  / 2

COLON => shift 32

-----

State 29:

0 : Typ -> . LPAREN Typ RPAREN  / 10
1 : Typ -> . Typ ARROW Typ  / 10
1 : Typ -> Typ ARROW . Typ  / 10
2 : Typ -> . NAT  / 10

LPAREN => shift 26
NAT => shift 25
Typ => goto 33

-----

State 30:

0 : Typ -> LPAREN Typ . RPAREN  / 10
1 : Typ -> Typ . ARROW Typ  / 9

RPAREN => shift 34
ARROW => shift 29

-----

State 31:

9 : ExpAtom -> IFZ Exp LBRACE BarOrNot ZERO DARROW Exp . BAR SUCC IDENT DARROW Exp RBRACE  / 4

BAR => shift 35

-----

State 32:

0 : Typ -> . LPAREN Typ RPAREN  / 13
1 : Typ -> . Typ ARROW Typ  / 13
2 : Typ -> . NAT  / 13
14 : Exp -> FUN IDENT LPAREN IDENT COLON Typ RPAREN COLON . Typ IS Exp  / 2

LPAREN => shift 26
NAT => shift 25
Typ => goto 36

-----

State 33:

1 : Typ -> Typ . ARROW Typ  / 10
1 : Typ -> Typ ARROW Typ .  / 10

RPAREN => reduce 1
ARROW => shift 29, reduce 1  PRECEDENCE
IS => reduce 1

-----

State 34:

0 : Typ -> LPAREN Typ RPAREN .  / 10

RPAREN => reduce 0
ARROW => reduce 0
IS => reduce 0

-----

State 35:

9 : ExpAtom -> IFZ Exp LBRACE BarOrNot ZERO DARROW Exp BAR . SUCC IDENT DARROW Exp RBRACE  / 4

SUCC => shift 37

-----

State 36:

1 : Typ -> Typ . ARROW Typ  / 13
14 : Exp -> FUN IDENT LPAREN IDENT COLON Typ RPAREN COLON Typ . IS Exp  / 2

ARROW => shift 29
IS => shift 38

-----

State 37:

9 : ExpAtom -> IFZ Exp LBRACE BarOrNot ZERO DARROW Exp BAR SUCC . IDENT DARROW Exp RBRACE  / 4

IDENT => shift 39

-----

State 38:

5 : ExpAtom -> . LPAREN Exp RPAREN  / 4
6 : ExpAtom -> . IDENT  / 4
7 : ExpAtom -> . ZERO  / 4
8 : ExpAtom -> . NUMBER  / 4
9 : ExpAtom -> . IFZ Exp LBRACE BarOrNot ZERO DARROW Exp BAR SUCC IDENT DARROW Exp RBRACE  / 4
10 : ExpApp -> . ExpAtom  / 4
11 : ExpApp -> . ExpApp ExpAtom  / 4
12 : ExpApp -> . SUCC ExpAtom  / 4
13 : Exp -> . ExpApp  / 2
14 : Exp -> . FUN IDENT LPAREN IDENT COLON Typ RPAREN COLON Typ IS Exp  / 2
14 : Exp -> FUN IDENT LPAREN IDENT COLON Typ RPAREN COLON Typ IS . Exp  / 2

IDENT => shift 6
LPAREN => shift 5
ZERO => shift 4
SUCC => shift 3
NUMBER => shift 7
IFZ => shift 2
FUN => shift 1
ExpAtom => goto 9
Exp => goto 40
ExpApp => goto 8

-----

State 39:

9 : ExpAtom -> IFZ Exp LBRACE BarOrNot ZERO DARROW Exp BAR SUCC IDENT . DARROW Exp RBRACE  / 4

DARROW => shift 41

-----

State 40:

14 : Exp -> FUN IDENT LPAREN IDENT COLON Typ RPAREN COLON Typ IS Exp .  / 2

$ => reduce 14
LBRACE => reduce 14
RBRACE => reduce 14
RPAREN => reduce 14
BAR => reduce 14

-----

State 41:

5 : ExpAtom -> . LPAREN Exp RPAREN  / 14
6 : ExpAtom -> . IDENT  / 14
7 : ExpAtom -> . ZERO  / 14
8 : ExpAtom -> . NUMBER  / 14
9 : ExpAtom -> . IFZ Exp LBRACE BarOrNot ZERO DARROW Exp BAR SUCC IDENT DARROW Exp RBRACE  / 14
9 : ExpAtom -> IFZ Exp LBRACE BarOrNot ZERO DARROW Exp BAR SUCC IDENT DARROW . Exp RBRACE  / 4
10 : ExpApp -> . ExpAtom  / 14
11 : ExpApp -> . ExpApp ExpAtom  / 14
12 : ExpApp -> . SUCC ExpAtom  / 14
13 : Exp -> . ExpApp  / 15
14 : Exp -> . FUN IDENT LPAREN IDENT COLON Typ RPAREN COLON Typ IS Exp  / 15

IDENT => shift 6
LPAREN => shift 5
ZERO => shift 4
SUCC => shift 3
NUMBER => shift 7
IFZ => shift 2
FUN => shift 1
ExpAtom => goto 9
Exp => goto 42
ExpApp => goto 8

-----

State 42:

9 : ExpAtom -> IFZ Exp LBRACE BarOrNot ZERO DARROW Exp BAR SUCC IDENT DARROW Exp . RBRACE  / 4

RBRACE => shift 43

-----

State 43:

9 : ExpAtom -> IFZ Exp LBRACE BarOrNot ZERO DARROW Exp BAR SUCC IDENT DARROW Exp RBRACE .  / 4

$ => reduce 9
IDENT => reduce 9
LBRACE => reduce 9
RBRACE => reduce 9
LPAREN => reduce 9
RPAREN => reduce 9
BAR => reduce 9
ZERO => reduce 9
NUMBER => reduce 9
IFZ => reduce 9

-----

lookahead 0 = $
lookahead 1 = $ IDENT LPAREN ZERO NUMBER IFZ
lookahead 2 = $ LBRACE RBRACE RPAREN BAR
lookahead 3 = IDENT LBRACE LPAREN ZERO NUMBER IFZ
lookahead 4 = $ IDENT LBRACE RBRACE LPAREN RPAREN BAR ZERO NUMBER IFZ
lookahead 5 = LBRACE
lookahead 6 = IDENT LPAREN RPAREN ZERO NUMBER IFZ
lookahead 7 = RPAREN
lookahead 8 = ZERO
lookahead 9 = RPAREN ARROW
lookahead 10 = RPAREN ARROW IS
lookahead 11 = IDENT LPAREN BAR ZERO NUMBER IFZ
lookahead 12 = BAR
lookahead 13 = ARROW IS
lookahead 14 = IDENT RBRACE LPAREN ZERO NUMBER IFZ
lookahead 15 = RBRACE

*)

struct
  local
    structure Value =
    struct
      datatype nonterminal =
        nonterminal
      | string of Arg.string
      | int of Arg.int
      | typ of Arg.typ
      | unittp of Arg.unittp
      | exp of Arg.exp
    end
    structure ParseEngine =
      ParseEngineFun
        (structure Streamable = Streamable
         type terminal = Arg.terminal
         type value = Value.nonterminal
         val dummy = Value.nonterminal
         fun read terminal =
           (case terminal of
              Arg.IDENT x => (1, Value.string x)
            | Arg.STRING x => (2, Value.string x)
            | Arg.LANGLE => (3, Value.nonterminal)
            | Arg.RANGLE => (4, Value.nonterminal)
            | Arg.LBRACE => (5, Value.nonterminal)
            | Arg.RBRACE => (6, Value.nonterminal)
            | Arg.LBRACKET => (7, Value.nonterminal)
            | Arg.RBRACKET => (8, Value.nonterminal)
            | Arg.LPAREN => (9, Value.nonterminal)
            | Arg.RPAREN => (10, Value.nonterminal)
            | Arg.ARROW => (11, Value.nonterminal)
            | Arg.BAR => (12, Value.nonterminal)
            | Arg.COLON => (13, Value.nonterminal)
            | Arg.COMMA => (14, Value.nonterminal)
            | Arg.DARROW => (15, Value.nonterminal)
            | Arg.DOT => (16, Value.nonterminal)
            | Arg.EQUAL => (17, Value.nonterminal)
            | Arg.PLUS => (18, Value.nonterminal)
            | Arg.STAR => (19, Value.nonterminal)
            | Arg.SEMICOLON => (20, Value.nonterminal)
            | Arg.NAT => (21, Value.nonterminal)
            | Arg.ZERO => (22, Value.nonterminal)
            | Arg.SUCC => (23, Value.nonterminal)
            | Arg.NUMBER x => (24, Value.int x)
            | Arg.IFZ => (25, Value.nonterminal)
            | Arg.FUN => (26, Value.nonterminal)
            | Arg.IS => (27, Value.nonterminal)))
  in
    val parse = ParseEngine.parse
      ( ParseEngine.next5x1
          "\128\135\128\128\128\128\128\128\128\134\128\128\128\128\128\128\128\128\128\128\128\128\133\132\136\131\130\128\128\128\128\128\128\140\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\135\128\128\128\128\128\128\128\134\128\128\128\128\128\128\128\128\128\128\128\128\133\132\136\131\130\128\128\128\128\128\128\135\128\128\128\128\128\128\128\134\128\128\128\128\128\128\128\128\128\128\128\128\133\128\136\131\128\128\128\128\128\128ww\128\128\128ww\128\128ww\128w\128\128\128\128\128\128\128\128\128w\128ww\128\128\128\128\128\128\128\135\128\128\128\128\128\128\128\134\128\128\128\128\128\128\128\128\128\128\128\128\133\132\136\131\130\128\128\128\128\128xx\128\128\128xx\128\128xx\128x\128\128\128\128\128\128\128\128\128x\128xx\128\128\128\128\128\128vv\128\128\128vv\128\128vv\128v\128\128\128\128\128\128\128\128\128v\128vv\128\128\128\128\128\128q\135\128\128\128qq\128\128\134q\128q\128\128\128\128\128\128\128\128\128\133\128\136\131\128\128\128\128\128\128tt\128\128\128tt\128\128tt\128t\128\128\128\128\128\128\128\128\128t\128tt\128\128\128\128\128\128\127\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\145\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\146\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128rr\128\128\128rr\128\128rr\128r\128\128\128\128\128\128\128\128\128r\128rr\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\147\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128ss\128\128\128ss\128\128ss\128s\128\128\128\128\128\128\128\128\128s\128ss\128\128\128\128\128\128\128\148\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\150\128\128\128\128\128\128\128\128\128{\128\128\128\128\128\128\128\128\128yy\128\128\128yy\128\128yy\128y\128\128\128\128\128\128\128\128\128y\128yy\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\151\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\152\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128z\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\155\128\128\128\128\128\128\128\128\128\128\128\154\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\156\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\157\158\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128||\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128|\128\128\128\128\128\128\128\128\128\128\128\128\128\155\128\128\128\128\128\128\128\128\128\128\128\154\128\128\128\128\128\128\128\128\128\128\128\135\128\128\128\128\128\128\128\134\128\128\128\128\128\128\128\128\128\128\128\128\133\132\136\131\130\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\161\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\155\128\128\128\128\128\128\128\128\128\128\128\154\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\163\158\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\164\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\155\128\128\128\128\128\128\128\128\128\128\128\154\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128}\158\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128}\128\128\128\128\128\128\128\128\128\128\128\128\128\128~~\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128~\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\166\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\158\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\167\128\128\128\128\128\168\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\135\128\128\128\128\128\128\128\134\128\128\128\128\128\128\128\128\128\128\128\128\133\132\136\131\130\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\170\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128p\128\128\128\128pp\128\128\128p\128p\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\135\128\128\128\128\128\128\128\134\128\128\128\128\128\128\128\128\128\128\128\128\133\132\136\131\130\128\128\128\128\128\128\128\128\128\128\128\172\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128uu\128\128\128uu\128\128uu\128u\128\128\128\128\128\128\128\128\128u\128uu\128\128\128\128\128\128"
      , ParseEngine.next5x1
          "\128\128\137\138\136\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\137\140\136\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\141\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\137\142\136\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\143\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\148\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\152\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\158\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\137\159\136\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\161\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\164\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\137\168\136\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\137\170\136\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128"
      , Vector.fromList
          [ ( 0
            , 3
            , (fn _ :: Value.typ (arg0) :: _ :: rest =>
                 Value.typ (Arg.typ_id arg0) :: rest
                | _ => raise (Fail "bad parser"))
            )
          , ( 0
            , 3
            , (fn Value.typ (arg0) :: _ :: Value.typ (arg1) :: rest =>
                 Value.typ (Arg.typ_arrow {2 = arg0, 1 = arg1}) :: rest
                | _ => raise (Fail "bad parser"))
            )
          , ( 0
            , 1
            , (fn _ :: rest => Value.typ (Arg.typ_nat {}) :: rest
                | _ => raise (Fail "bad parser"))
            )
          , (1, 0, (fn rest => Value.unittp (Arg.unittm {}) :: rest))
          , ( 1
            , 1
            , (fn _ :: rest => Value.unittp (Arg.unittm {}) :: rest
                | _ => raise (Fail "bad parser"))
            )
          , ( 2
            , 3
            , (fn _ :: Value.exp (arg0) :: _ :: rest =>
                 Value.exp (Arg.exp_id arg0) :: rest
                | _ => raise (Fail "bad parser"))
            )
          , ( 2
            , 1
            , (fn Value.string (arg0) :: rest =>
                 Value.exp (Arg.exp_var arg0) :: rest
                | _ => raise (Fail "bad parser"))
            )
          , ( 2
            , 1
            , (fn _ :: rest => Value.exp (Arg.exp_zero {}) :: rest
                | _ => raise (Fail "bad parser"))
            )
          , ( 2
            , 1
            , (fn Value.int (arg0) :: rest =>
                 Value.exp (Arg.exp_number arg0) :: rest
                | _ => raise (Fail "bad parser"))
            )
          , ( 2
            , 13
            , (fn _ ::
                   Value.exp (arg0) ::
                     _ ::
                       Value.string (arg1) ::
                         _ ::
                           _ ::
                             Value.exp (arg2) ::
                               _ :: _ :: _ :: _ :: Value.exp (arg3) :: _ :: rest =>
                 Value.exp (Arg.exp_ifz
                   {4 = arg0, 3 = arg1, 2 = arg2, 1 = arg3}) :: rest
                | _ => raise (Fail "bad parser"))
            )
          , ( 4
            , 1
            , (fn Value.exp (arg0) :: rest =>
                 Value.exp (Arg.exp_id arg0) :: rest
                | _ => raise (Fail "bad parser"))
            )
          , ( 4
            , 2
            , (fn Value.exp (arg0) :: Value.exp (arg1) :: rest =>
                 Value.exp (Arg.exp_ap {2 = arg0, 1 = arg1}) :: rest
                | _ => raise (Fail "bad parser"))
            )
          , ( 4
            , 2
            , (fn Value.exp (arg0) :: _ :: rest =>
                 Value.exp (Arg.exp_succ arg0) :: rest
                | _ => raise (Fail "bad parser"))
            )
          , ( 3
            , 1
            , (fn Value.exp (arg0) :: rest =>
                 Value.exp (Arg.exp_id arg0) :: rest
                | _ => raise (Fail "bad parser"))
            )
          , ( 3
            , 11
            , (fn Value.exp (arg0) ::
                   _ ::
                     Value.typ (arg1) ::
                       _ ::
                         _ ::
                           Value.typ (arg2) ::
                             _ ::
                               Value.string (arg3) ::
                                 _ :: Value.string (arg4) :: _ :: rest =>
                 Value.exp (Arg.exp_fun
                   {5 = arg0, 2 = arg1, 1 = arg2, 4 = arg3, 3 = arg4}) :: rest
                | _ => raise (Fail "bad parser"))
            )
          ]
      , (fn Value.exp x => x | _ => raise (Fail "bad parser"))
      , Arg.error
      )
  end
end
